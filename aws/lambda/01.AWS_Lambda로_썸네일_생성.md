# 01.AWS Lambda로 썸네일 생성

#TIL/aws

[당근마켓 seapy님의 블로그](https://medium.com/daangn/aws-lambda%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%8D%B8%EB%84%A4%EC%9D%BC-%EC%83%9D%EC%84%B1-%EA%B0%9C%EB%B0%9C-%ED%9B%84%EA%B8%B0-acc278d49980)

---

유저가 웹 사이트 속도의 첫 인상을 결정하는 것은 아마도 이미지 로딩시간일 것이다.

300x300 사이즈의 이미지를 로딩하는데 10MB용량을 로딩하며, 심지어 페이지에 다시 돌아왔을 때 캐싱이 되어있지 않다면
유저는 그 사이트는 느리다고 생각할지 모른다.

이를 해결하는 방법으로 리사이징을 한다거나, 화질이 낮은 썸네일 이미지를 서빙하는 방법이 있다.
위 기술 블로그에선 AWS Lambda로 썸네일을 생성하는 방법을 소개한다.

근데 굳이 ```AWS lambda```로 썸네일을 생성할 필요는 없지 않는가? 최초에 ```"POST /upload"```와 같은 요청이 서버로 오고, 다시 ```S3```로 업로드하는 방식일 것이다. 

하지만, 이렇게 하면 이미지 용량이 크거나, 여러 요청이 들어올 때 서버에 부담이 갈 수 있다는 단점이 있다. 

이미지 스트림을 읽어서 S3에 그대로 업로드하면 되는데
서버 자원을 사용하는 것이 좋아보이지는 않는다. 

이미지 업로드 및 썸네일 생성 목적 외에도 다양한 목적으로 쓰일 수 있을 것 같은데, 더 많은 예시를 찾아봐야겠다.


## Lambda function code

```javascript
"use strict";

let aws = require("aws-sdk");
let s3 = new aws.S3({ apiVersion: "2006-03-01" });
let async = require("async");
let gm = require("gm").subClass({ imageMagick: true });

const supportImageTypes = ["jpg", "jpeg", "png", "gif"];
const ThumbnailSizes = {
  PROFILE: [
    { size: 80, alias: "s", type: "crop" },
    { size: 256, alias: "m", type: "crop" },
    { size: 640, alias: "l", type: "crop" },
  ],
  ARTICLE: [
    { size: 192, alias: "s" },
    { size: 1280, alias: "l" },
  ],
  MESSAGE: [{ size: 1280, alias: "l" }],
  BUSINESS_ARTICLE_THUMB: [{ size: 192, alias: "s", type: "crop" }],
  sizeFromKey: function (key) {
    const type = key.split("/")[1];
    if (type === "article") {
      return ThumbnailSizes.ARTICLE;
    } else if (type === "profile") {
      return ThumbnailSizes.PROFILE;
    } else if (type === "message") {
      return ThumbnailSizes.MESSAGE;
    } else if (type === "business_article_thumb") {
      return ThumbnailSizes.BUSINESS_ARTICLE_THUMB;
    }
    return null;
  },
};

function destKeyFromSrcKey(key, suffix) {
  return key.replace("origin/", `resize/${suffix}/`);
}

function resizeAndUpload(
  response,
  size,
  srcKey,
  srcBucket,
  imageType,
  callback
) {
  const pixelSize = size["size"];
  const resizeType = size["type"];

  function resizeWithAspectRatio(resizeCallback) {
    gm(response.Body)
      .autoOrient()
      .resize(pixelSize, pixelSize, ">")
      .noProfile()
      .quality(95)
      .toBuffer(imageType, function (err, buffer) {
        if (err) {
          resizeCallback(err);
        } else {
          resizeCallback(null, response.ContentType, buffer);
        }
      });
  }

  function resizeWithCrop(resizeCallback) {
    gm(response.Body)
      .autoOrient()
      .resize(pixelSize, pixelSize, "^")
      .gravity("Center")
      .extent(pixelSize, pixelSize)
      .noProfile()
      .quality(95)
      .toBuffer(imageType, function (err, buffer) {
        if (err) {
          resizeCallback(err);
        } else {
          resizeCallback(null, response.ContentType, buffer);
        }
      });
  }

  async.waterfall(
    [
      function resize(next) {
        if (resizeType == "crop") {
          resizeWithCrop(next);
        } else {
          resizeWithAspectRatio(next);
        }
      },
      function upload(contentType, data, next) {
        const destKey = destKeyFromSrcKey(srcKey, size["alias"]);
        s3.putObject(
          {
            Bucket: srcBucket,
            Key: destKey,
            ACL: "public-read",
            Body: data,
            ContentType: contentType,
          },
          next
        );
      },
    ],
    (err) => {
      if (err) {
        callback(new Error(`resize to ${pixelSize} from ${srcKey} : ${err}`));
      } else {
        callback(null);
      }
    }
  );
}

exports.handler = (event, context, callback) => {
  const bucket = event.Records[0].s3.bucket.name;
  const key = decodeURIComponent(
    event.Records[0].s3.object.key.replace(/\+/g, " ")
  );
  // Lambda 타임아웃 에러는 로그에 자세한 정보가 안남아서 S3 파일 이름으로 나중에 에러처리하기위해 에러를 출력하는 코드
  const timeout = setTimeout(() => {
    callback(new Error(`[FAIL]:${bucket}/${key}:TIMEOUT`));
  }, context.getRemainingTimeInMillis() - 500);

  if (!key.startsWith("origin/")) {
    clearTimeout(timeout);
    callback(new Error(`[FAIL]:${bucket}/${key}:Unsupported image path`));
    return;
  }

  const params = {
    Bucket: bucket,
    Key: key,
  };
  const keys = key.split(".");
  const imageType = keys.pop().toLowerCase();
  if (
    !supportImageTypes.some((type) => {
      return type == imageType;
    })
  ) {
    clearTimeout(timeout);
    callback(new Error(`[FAIL]:${bucket}/${key}:Unsupported image type`));
    return;
  }

  async.waterfall(
    [
      function download(next) {
        s3.getObject(params, next);
      },
      function transform(response, next) {
        let sizes = ThumbnailSizes.sizeFromKey(key);
        if (sizes == null) {
          next(
            new Error(
              `thumbnail type is undefined(allow articles or profiles), ${key}`
            )
          );
          return;
        }
        async.eachSeries(
          sizes,
          function (size, seriesCallback) {
            resizeAndUpload(
              response,
              size,
              key,
              bucket,
              imageType,
              seriesCallback
            );
          },
          next
        );
      },
    ],
    (err) => {
      if (err) {
        clearTimeout(timeout);
        callback(new Error(`[FAIL]:${bucket}/${key}:resize task ${err}`));
      } else {
        clearTimeout(timeout);
        callback(null, "complete resize");
      }
    }
  );
};
```
