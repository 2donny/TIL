# DB

1. Index란 한 컬럼을 기준으로 메모리 영역에 목차를 생성하는 것이다.
    1. Insert, Update, Delete 성능을 희생하고, Select 성능을 향상시킨다.
    2. *Update, Delete는 행위가 느린 것이지, 해당 데이터를 조회하는 것은 Index가 있으면 빠릅니다.
    3. Cardinality는 해당 컬럼의 중복된 수치를 나타낸다. 카디널리티가 높은 것을 인덱스로 잡아야한다. 왜냐면 인덱스로 최대한 효율을 뽑아내려면, 해당 인덱스로 많은 부분을 걸러내야하기 때문입니다.
2. Multi-comlun-index 사용 시에는
    1. 카디널리티가 높은 -> 낮은 순으로 하는게 성능적으로 훨씬 좋다.
        1. 최근에는 옵티마이저에 의해서 지켜주지 않아도 되긴한다.
    2. 무조건 첫번째 인덱스 컬럼이 where절에 포함되어야 인덱스를 탄다.
3. Clustered-index, Non-Clustered-index
    1. Clusted-Index, 인덱스가 데이터에 밀집하게 연결되어있다, 또한 순서대로 정렬되어있는 인덱스를 말합니다.
        1. 장점) 인덱스가 정렬되어있다보니 범위검색에 강력합니다. (예를들어 성적순으로 인덱슬르 매겼다면 30~50등 사이의 데이터가져올 떄)
        2. 단점) 정렬되어있다보니, 존재하는 pk 사이에 데이터가 insert될 때 매우 불리하다. 중간에 추가된다고 하면 중간부터 끝까지 모든 데이터를 한 칸씩 밀고 삽입해야합니다. 
        3. 특징) 
            1. 한 테이블의 하나의 조건으로만 정렬이된다. Primary key와 매우 유사하다. Pk, Clustered-index 둘 다 테이블당 하나만 존재할 수 있다.
            2. 공간지역성 때문에 범위 검색시에 주변 데이터를 레지스터/캐시에 긁어와서 실행함으로써 성능을 많이 높일 수 잇다.
4. 커버링 인덱스
    1. Where, group by, having 절에 모든 컬럼이 Index인 경우에
    2. 데이터 블록까지 가지 않고 메모리 영역의 인덱스에서 모든 쿼리가 수행된다.
5. Non-Clustered란 데이터와 연결되어있지 않고(Non-clustered) ‘인덱스’랑 연결이 되어서, 데이터를 간접참조를 하고 있다. 인덱스의 순서가 정렬되지 않는다. 여기서 ‘인덱스’는 해쉬된 인덱스라서 굉장히 빨리 찾을 수 있다